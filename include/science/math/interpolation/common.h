/////////////////////////////////////////////////////////////
#ifndef SCIENCE_MATH_INTERPOL_COMMON_H_INCLUDED_
#define SCIENCE_MATH_INTERPOL_COMMON_H_INCLUDED_


#include <science/core/type.hpp>

#include <stdio.h>
#include <stdint.h>


/////////////////////////////////////////////////////////////
namespace science {

#define INTK(K, F1, F2) \
	((F1) + (K)*((F2) - (F1)))
/* interpol.c */
typedef struct {
	sreal_t arg, min, max;
} Scale;

/** \brief Перечисление форматов файлов */
typedef enum {
	  TEXT = 0x01		/**< тектовый формат */
	, BINARY = 0x02		/**< бинарный формат */
} FormatFile;

/* БД для линейной интерполяции (ЛИ) */
typedef struct {
	Scale **scales;			/* Шкалы аргументов */
	int* len;				/* Длины шкал аргументов */
    int users;				/* Количество пользователей данной БД */
	sreal_t *data;			/* Данные для интерполяции */
	unsigned nscales;		/* Число шкал */
	unsigned ndata;			/* Число точек данных */
	char* path;				/* Путь к файлу */
    bool is_free;			/* Признак, что данные были удалены после закрытия интерполятора и данная БД может использоваться для вновь открытых файлов */

	/**********************/
	/* Кодированные комментарии */
	/* Связано с описанием файла */
	int* description_file;				/*	Описание файла							 */
	int length_description_file;		/*	Длинна описании файла					 */
	/* Связано с описанием аргумента */
	int** description_argument;			/*	Описание [i] аргумента					 */
	int* length_description_argument;	/*	Длинна строки в описании [i] аргумента	 */
	/* Связано с именем аргумента */
	int** name_argument;				/*	Имя [i] аргумента						 */
	int* length_name_argument;			/*	Длинна имение [i] аргумент				 */
	/* Связано с описанием таблицы */
	int* description_table;				/*	Описание таблицы						 */
	int length_description_table;		/*	Длинна каждой строки в описании таблицы	 */
} Interpol;
extern Interpol *interpol;	/* Массив баз данных для ЛИ */
extern unsigned ninterpol;	/* Количество открытых БД для ЛИ */

void changescal(int i, int iscal, int n, sreal_t *scale);
sreal_t interinter(int i, int j, int n, sreal_t *arg);


/*!
*****************************************************************************
	@brief Функция добавление/установление/изменение шкалы.
	@param pos - позиция аргумента.
	@param arg_arr - массив значения шкалы.
	@param size - длинна массива.
******************************************************************************
*/
void set_scale(int const pos, sreal_t const* arg_arr, unsigned const size);


/*!
*****************************************************************************
	@brief Функция добавление точек данных.
	@param arg_ndata - массив точек данных.
	@param size_k - длинна массива.
	@param set_or_add - перезаписать данные (true) или добавить (false).
******************************************************************************
*/
void set_ndata(sreal_t const* arg_ndata, unsigned const size_k, bool set_or_add);


/*!
*****************************************************************************
	@brief Функция добавление точек данных.
	@param str - строка точек данных.
	@param set_or_add - перезаписать данные (true) или добавить (false).
******************************************************************************
*/
void set_ndata(char const* str, bool set_or_add);


/*!
*****************************************************************************
	@brief Функция устанавливает кол-во аруменов для интерполяции.
	@param am - число (кол-во) аргументов.
******************************************************************************
*/
const int set_amount_scales(const int am);


/*!
*****************************************************************************
	@brief Функция устанавливает описание файла.
	@param const char * opis - описание файла.
******************************************************************************
*/
void set_desc_file(const wchar_t* opis);


/*!
*****************************************************************************
	@brief Функция устанавливает имя аргумента.
	@param const char * name - имя аргумента.
	@param const int key - ключ к какому аргументу установить имя.
******************************************************************************
*/
void set_name_scale(const int key, const wchar_t * name);


/*!
*****************************************************************************
	@brief Функция устанавливает описание аргумента.
	@param const char * desc - описание аргумента.
	@param const int key - ключ к какому аргументу установить описание.
******************************************************************************
*/
void set_desc_scale(const int key, const wchar_t * desc);


/*!
*****************************************************************************
	@brief Функция устанавливает описание таблицы.
	@param const char * opis - описание таблицы.
******************************************************************************
*/
void set_desc_table(const wchar_t * opis);


/*!
*****************************************************************************
	@brief  Функция возвращающая определенную шкалу. С массивом ее аргументов.
	@param  int key - Ключ к какую именно шкалу возвращаем.
	@return Scale*  - Массив аргументов шкалы.
******************************************************************************
*/
Scale* get_scales(int key);


/*!
*****************************************************************************
	@brief  Функция возвращающая количество шкал.
	@return int - число шкал.
******************************************************************************
*/
int	get_nscales();


/*!
*****************************************************************************
	@brief Функция возвращающая размер определенной шкалы.
	@param int key - ключ по которому будет искаться длинна шкалы.
	@return int - число длинны (размер) шкалы.
******************************************************************************
*/
int get_lens(int key);


/*!
*****************************************************************************
	@brief Функция возвращающая значения точек данных (табличных зачений).
	@return sreal_t* - одномернный массив табличных значений.
******************************************************************************
*/
sreal_t* get_data();


/*!
*****************************************************************************
	@brief Функция возвращающая количество точек данных (табличные значения).
	@return int - число длинна массива.
******************************************************************************
*/
int get_ndata();


/*!
*****************************************************************************
	@brief Функция возвращающая описание файла
	@return const wchar_t * - элементов
******************************************************************************
*/
const wchar_t* get_description_file_();


/*!
*****************************************************************************
	@brief Функция возвращающая описание аргумента по ключу.
	@param int key - позиция аргумента.
	@return const wchar_t* - описание аругмента
******************************************************************************
*/
const wchar_t* get_description_scale(int key);


/*!
*****************************************************************************
	@brief Функция возвращающая имя аргумента по ключу.
	@param int key - позиция аргумента.
	@return iconst wchar_t* - имени аргумента.
******************************************************************************
*/
const wchar_t* get_name_scale(int key);


/*!
*****************************************************************************
	@brief Функция возвращающая описание таблицы.
	@return const wchar_t* описание таблицы
******************************************************************************
*/
const wchar_t* get_description_table_();


/////////////////////////////////////////////////////////////

/*!
*****************************************************************************
	@brief Переводит символ к численным значения (кодирует).
    @param const wchar_t с - символ для перевода (кодирования).
	@return int * - массив кодов строки.

	@note связные функция wchar_t EnCod(int buf);.
******************************************************************************
*/
int Cod(const wchar_t c);


/*!
*****************************************************************************
	@brief Переводит строки к численные значения к строкам.
	@param  int * buf - строк для перевода (декодирования).
	@return char * - массив строк.

	@note связные функция int * Cod(const wchar_t * buf);.
******************************************************************************
*/
const wchar_t EnCod(int buf);


size_t size(Interpol*);	/* Возвращает размер объекта при записи, в байтах */
size_t dumpb(Interpol* ii, char const* fname);	/* Сохранение данных для интерполяции в бинарном формате */
size_t dumpt(Interpol* ii, char const* fname);	/* Запись данных в файл в текстовом формате */

/////////////////////////////////////////////////////////////
sreal_t interpolate(int i, int n, sreal_t const* arg);


/////////////////////////////////////////////////////////////
int mkinterpol(const char* path, FormatFile const fileT = TEXT);


/////////////////////////////////////////////////////////////
void mkfree(unsigned const i);




/* util.c */
bool findext(const char * dest, const char * srs); /* Поиск в dest расширения srs без точки, только "txt" не ".txt"*/
void *emalloc(unsigned int size);
void *emallocz(unsigned int size);
void* erealloc(void* ptr, unsigned int size);
void* ereallocz(void* ptr, unsigned int size);
int tokenize(char *res[], unsigned int reslen, char *str, char delim);	/* Подсчет числа слов в строке, разделенных разделиетелм delim */
int ntokenize(char* res[], unsigned int reslen, char* str, char* delim);	/* Подсчет числа слов в строке, разделенных набором разделителей delim */
int wntokenize(wchar_t* res[], unsigned int reslen, wchar_t* str, wchar_t* delim);
void reader(FILE *stream, void(*getline)(int, const char *));
void wreader(FILE* stream, void(*getline)(int, const wchar_t*));
size_t extlen(char const* fname);	// количество символов в расширении файла
void setext(char* dest, char const* src, char const* ext);	// Устанавливаем нужное расширение в имени файла
bool isvalid(char const c);	/* Проверка является ли символ допустимым */
size_t validlen(char* str);	/* Подсчет количества допустимых символов в строке */
size_t validlens(char* str);	/* Подсчет количества допустимых символов в строке, допуская не более 1 whitespace подряд */
uint16_t tovalid(char const c);	/* Преобразовать символ в допустимое число. Возвращает uint16_t(-1) при невозмонжости */
size_t tovalids(char* base, uint16_t* valids);	/* Преобразование текстовой строки в числовую строку допустимых символов */
size_t fromvalid(uint16_t* base, char* str, size_t ulen);	/* Преборазование числовой строки base размера ulen в текстовую без контроля размера. Размер строки str должен обеспечить добавление '# ' в начале */

} // namespace science



#endif